---
title: "Intertemporal Choice"
subtitle: "Life Cycle Models, Labor Supply, OLG, and the Envelope Condition"
format: revealjs
date: 2025-02-03
pyodide:
  packages:
    - numpy
    - scipy
    - matplotlib
    - sympy
---

# The Two-Period Life Cycle Model

## The Fisher Problem

Irving Fisher's two-period consumption model: a consumer lives for two periods with no uncertainty.

**Lifetime value:**

$$V(c_1, c_2) = u(c_1) + \beta \, u(c_2)$$

where $\beta \in (0,1)$ is the time preference factor.

**Assumptions:**

- Marginal utility is positive: $u'(\cdot) > 0$
- Diminishing marginal utility: $u''(\cdot) < 0$

## Budget Constraints

The consumer begins with bank balances $b_1$ and earns income $y_1$ in period 1, $y_2$ in period 2.

**Dynamic budget constraint (DBC):**

$$b_2 = (b_1 + y_1 - c_1) R$$

**Intertemporal budget constraint (IBC):**

$$c_1 + \frac{c_2}{R} = b_1 + \underbrace{y_1 + \frac{y_2}{R}}_{\equiv \, h_1 \text{ (human wealth)}}$$

The PDV of lifetime spending equals the PDV of lifetime resources.

## The Lagrangian

$$\max_{\{c_1, c_2\}} \; u(c_1) + \beta \, u(c_2) \quad \text{s.t.} \quad c_2 = (b_1 + y_1 - c_1)R + y_2$$

The Lagrangian is:

$$\mathcal{L} = u(c_1) + \beta \, u(c_2) + \lambda\left[c_2 - (b_1 + y_1 - c_1)R - y_2\right]$$

**First order conditions:**

$$\frac{\partial \mathcal{L}}{\partial c_1} = u'(c_1) + R\lambda = 0$$

$$\frac{\partial \mathcal{L}}{\partial c_2} = \beta \, u'(c_2) + \lambda = 0$$

## The Euler Equation

From the FOCs: $\lambda = -\beta \, u'(c_2)$. Substituting into the first condition:

$$u'(c_1) - R \, \beta \, u'(c_2) = 0$$

$$\boxed{u'(c_1) = R \, \beta \, u'(c_2)}$$

The intertemporal price $R$ determines the tradeoff: giving up one unit of $c_1$ yields $R$ units of $c_2$.

## Code: Symbolic Euler Equation

```{pyodide}
#| output: asis
from sympy import symbols, Function, diff, solve, Eq
from sympy.printing.mathml import mathml

def show(expr):
    ml = mathml(expr, printer='presentation')
    print(f'<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">{ml}</math>')

c1, c2, b1, y1, y2, R, beta, lam = symbols(
    'c_1 c_2 b_1 y_1 y_2 R beta lambda', positive=True)
u = Function('u')

L = u(c1) + beta * u(c2) + lam * (c2 - (b1 + y1 - c1) * R - y2)

foc_c1 = diff(L, c1)
foc_c2 = diff(L, c2)
print('<p><b>FOC w.r.t. c1:</b></p>')
show(Eq(foc_c1, 0))
print('<p><b>FOC w.r.t. c2:</b></p>')
show(Eq(foc_c2, 0))

euler = Eq(u(c1).diff(c1), R * beta * u(c2).diff(c2))
print('<p><b>Euler equation:</b></p>')
show(euler)
```

## Intuition: Perturbation Argument

At the optimum $(c_1^*, c_2^*)$, reduce $c_1$ by $\epsilon$ and invest it:

$$\Delta \text{Utility} \approx \underbrace{u'(c_1^*)\epsilon}_{\text{loss today}} - \underbrace{\beta \, u'(c_2^*) R\epsilon}_{\text{gain tomorrow}}$$

If $\Delta \neq 0$, we have a contradiction: the consumer could do better.

- $\Delta > 0$: consume more today
- $\Delta < 0$: save more today
- $\Delta = 0$: **optimality** $\Rightarrow$ the Euler equation

## CRRA Utility and Consumption Growth

With constant relative risk aversion (CRRA) utility,

$$u(c) = \frac{c^{1-\rho}}{1-\rho}, \qquad u'(c) = c^{-\rho}$$

the Euler equation becomes:

$$c_1^{-\rho} = R\beta \, c_2^{-\rho} \quad \Longrightarrow \quad \frac{c_2}{c_1} = (R\beta)^{1/\rho}$$

The **intertemporal elasticity of substitution** is $1/\rho$:

$$\frac{d \log(c_2/c_1)}{d \log R} = \frac{1}{\rho}$$

## The Consumption Function

Using the Euler equation and the IBC:

$$c_1 = \frac{b_1 + h_1}{1 + R^{-1}(R\beta)^{1/\rho}}$$

**Log utility** ($\rho = 1$) simplifies to:

$$c_1 = \frac{b_1 + h_1}{1 + \beta}$$

The marginal propensity to consume out of wealth is $\frac{1}{1+\beta}$.

## Code: Consumption Response to R

```{pyodide}
import numpy as np
import matplotlib.pyplot as plt

rho_vals = [0.5, 1.0, 2.0, 4.0]
beta = 0.96
wealth = 100
R_vals = np.linspace(0.5, 2.0, 200)

fig, ax = plt.subplots()
for rho in rho_vals:
    denom = 1 + R_vals**(-1) * (R_vals * beta) ** (1 / rho)
    c1 = wealth / denom
    ax.plot(R_vals, c1, lw=2, label=rf'$\rho = {rho}$ (IES $= {1/rho:.1f}$)')
ax.set_xlabel('Gross interest rate $R$')
ax.set_ylabel('Consumption $c_1$')
ax.set_title('Higher IES $\\Rightarrow$ stronger response to $R$')
ax.legend()
ax.grid(True, alpha=0.3)
plt.show()
```

## Code: Fisher Diagram

```{pyodide}
import numpy as np
import matplotlib.pyplot as plt

R = 1.04
beta = 0.96
b1, y1, y2 = 10, 50, 30
total_wealth = b1 + y1 + y2 / R

c1_line = np.linspace(1, total_wealth - 1, 200)
c2_line = (total_wealth - c1_line) * R

c1_star = total_wealth / (1 + beta)
c2_star = (total_wealth - c1_star) * R

U_star = np.log(c1_star) + beta * np.log(c2_star)
c1_ic = np.linspace(5, total_wealth - 5, 200)
c2_ic = np.exp((U_star - np.log(c1_ic)) / beta)

fig, ax = plt.subplots()
ax.plot(c1_line, c2_line, 'b-', lw=2, label='Budget constraint')
ax.plot(c1_ic, c2_ic, 'r--', lw=1.5, label='Indifference curve')
ax.plot(c1_star, c2_star, 'ko', ms=8)
ax.annotate('Optimum', xy=(c1_star, c2_star),
            xytext=(c1_star + 5, c2_star + 5),
            arrowprops=dict(arrowstyle='->'))
ax.plot(y1 + b1, y2, 'gs', ms=8, label='Endowment')
ax.set_xlabel('$c_1$'); ax.set_ylabel('$c_2$')
ax.set_title('Fisher diagram')
ax.legend()
ax.grid(True, alpha=0.3)
plt.show()
```

## Code: Effect of Income Timing

```{pyodide}
import numpy as np
import matplotlib.pyplot as plt

beta = 0.96
R_vals = [0.90, 1.04, 1.20]

fig, axes = plt.subplots(1, 2, figsize=(10, 4))
titles = ['Saver: $y_1 = 80, y_2 = 0$', 'Borrower: $y_1 = 0, y_2 = 83.2$']
endowments = [(80, 0), (0, 83.2)]

for ax, (y1, y2), title in zip(axes, endowments, titles):
    for R in R_vals:
        tw = y1 + y2 / R
        c1_line = np.linspace(1, tw - 1, 200)
        c2_line = (tw - c1_line) * R
        c1_star = tw / (1 + beta)
        c2_star = (tw - c1_star) * R
        ax.plot(c1_line, c2_line, lw=1.5, label=f'$R={R}$')
        ax.plot(c1_star, c2_star, 'ko', ms=6)
    ax.plot(y1, y2, 'rs', ms=10, label='Endowment')
    ax.set_xlabel('$c_1$'); ax.set_ylabel('$c_2$')
    ax.set_title(title)
    ax.legend(fontsize=8)
    ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

## Fisherian Separation

The consumption growth profile

$$\frac{c_2}{c_1} = (R\beta)^{1/\rho}$$

depends **only** on $R$ and $\beta$, not on the income profile $(y_1, y_2)$.

Two consumers with the same lifetime wealth but different income timing have **identical** consumption paths.

This is a pervasive feature of models combining:

- Perfect foresight
- No liquidity constraints

## Income, Substitution, and Human Wealth Effects

When $R$ increases, three forces operate on $c_1$:

- **Substitution effect:** Future consumption is cheaper $\Rightarrow$ save more ($c_1 \downarrow$)
- **Income effect:** Higher return on savings $\Rightarrow$ richer ($c_1 \uparrow$)
- **Human wealth effect:** PDV of future income $h_1$ falls ($c_1 \downarrow$)

Summers (1981) argues the human wealth effect dominates quantitatively: for most consumers, the bulk of lifetime income is future labor income, so higher $R$ substantially reduces its present value.

## Code: Decomposing the Effect of R

```{pyodide}
import numpy as np
import matplotlib.pyplot as plt

beta = 0.96
R_vals = np.linspace(0.8, 1.5, 200)

# Same total wealth at R=1.04 but different income timing
y1_saver, y2_saver = 80, 0
y1_borr, y2_borr = 0, 83.2

fig, ax = plt.subplots()
for y1, y2, lab in [(y1_saver, y2_saver, 'Saver ($y_1=80$)'),
                     (y1_borr, y2_borr, 'Borrower ($y_2=83.2$)')]:
    tw = y1 + y2 / R_vals
    c1 = tw / (1 + beta)
    ax.plot(R_vals, c1, lw=2, label=lab)

ax.set_xlabel('Gross interest rate $R$')
ax.set_ylabel('Period-1 consumption $c_1$')
ax.set_title('Human wealth effect: borrowers hurt more by rising $R$')
ax.legend()
ax.grid(True, alpha=0.3)
plt.show()
```

# Consumption and Labor Supply

## Setup: Consumption and Leisure

Utility depends on both consumption $c_t$ and leisure $z_t$: $u(c_t, z_t)$

**Constraints:**

- Time allocation: $\ell_t + z_t = 1$
- Labor income: $y_t = W_t(1 - z_t)$
- Expenditure: $x_t = c_t + z_t W_t$

**FOC:** $W_t = u^z / u^c$ (wage = MRS between leisure and consumption)

## Stylized Facts on Labor Supply

Wages in the US have risen by a factor of 2 to 4 over the life cycle (youth to middle age), yet labor supply barely changes.

- Over long periods, hours worked have remained roughly stable despite large wage increases (Ramey and Francis, 2009)
- Across countries with vastly different per capita income, variation in leisure is small relative to variation in wages
- Cross-sectionally, vast wage differences produce only small leisure differences

These facts motivate the Cobb-Douglas specification: the expenditure share on leisure should be constant as wages rise.

## Cobb-Douglas Preferences

Assume Cobb-Douglas aggregation inside an outer function $f$:

$$u(c_t, z_t) = f\!\left(c_t^{1-\alpha} z_t^{\alpha}\right)$$

This implies $z_t W_t = c_t \eta$ where $\eta = \alpha / (1-\alpha)$.

**Key property:** the share of expenditure on leisure is constant as wages rise.

Utility simplifies to $f\!\left((W_t/\eta)^{-\alpha} c_t\right)$.

## Code: Cobb-Douglas Leisure Derivation

```{pyodide}
#| output: asis
from sympy import symbols, diff, solve, simplify, Function, Eq
from sympy.printing.mathml import mathml

def show(expr):
    ml = mathml(expr, printer='presentation')
    print(f'<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">{ml}</math>')

c, z, W, x, alpha = symbols('c z W x alpha', positive=True)
f = Function('f')

inner = c**(1 - alpha) * z**alpha
inner_sub = inner.subs(c, x - W * z)

foc = diff(inner_sub, z)
z_star = solve(foc, z)
z_opt = symbols('z_opt')
print('<p><b>Optimal leisure:</b></p>')
show(Eq(z_opt, z_star[0]))

eta = alpha / (1 - alpha)
c_val = x - W * z_star[0]
ratio = simplify(W * z_star[0] / c_val)
print('<p><b>Expenditure ratio Wz/c = alpha/(1-alpha) = eta (verified)</b></p>')
show(Eq(ratio, eta))
```

## Two-Period Model with Labor

With CRRA outer utility $f(\chi) = \chi^{1-\rho}/(1-\rho)$:

$$\frac{c_2}{c_1} = (R\beta)^{1/\rho} \left(\frac{W_2}{W_1}\right)^{-\alpha(1-\rho)/\rho}$$

**Log utility** ($\rho = 1$): consumption growth $c_2/c_1 = R\beta$ (no wage effect)

**Labor supply:** $\displaystyle\frac{1-\ell_2}{1-\ell_1} = \frac{R\beta \, W_1}{W_2}$ (work harder when wages are higher)

## Log Utility Consumption Level

With log utility, the IBC with labor becomes:

$$c_1(1+\beta)(1+\eta) = W_1 + R^{-1}W_2 \equiv h_1$$

Solving for consumption:

$$c_1 = \frac{h_1}{(1+\beta)(1+\eta)}$$

The $(1+\eta)$ factor captures the expenditure share allocated to leisure. Compared to the pure consumption model, the MPC out of human wealth is lower because part of each dollar funds leisure.

## Code: Consumption-Labor Tradeoff

```{pyodide}
import numpy as np
import matplotlib.pyplot as plt

alpha = 0.4
eta = alpha / (1 - alpha)
R, beta = 1.04, 0.96

W_ratio = np.linspace(0.5, 4.0, 200)
leisure_ratio = R * beta / W_ratio

ell_1 = 0.5
ell_2 = 1 - (1 - ell_1) * leisure_ratio

fig, ax = plt.subplots()
ax.plot(W_ratio, ell_2, 'b-', lw=2)
ax.axhline(ell_1, color='gray', ls='--', alpha=0.5, label=r'$\ell_1 = 0.5$')
ax.set_xlabel(r'Wage growth $W_2 / W_1$')
ax.set_ylabel(r'Period 2 labor supply $\ell_2$')
ax.set_title('Labor supply responds strongly to wage growth')
ax.set_ylim(0, 1)
ax.legend()
ax.grid(True, alpha=0.3)
plt.show()
```

## The Labor Supply Puzzle

With $R\beta = 1$ and $\ell_1 = 1/2$:

$$\ell_2 = \frac{2\omega + 1}{2(1+\omega)}$$

where $\omega = W_2/W_1 - 1$ is wage growth.

If $\omega = 2$: $\ell_2 = 5/6 \approx 0.83$

The model predicts middle-aged people work **67% more** than young people. This is inconsistent with the data: labor supply is about the same for 55-year-olds as for 25-year-olds.

## Code: Predicted vs Actual Labor Supply

```{pyodide}
import numpy as np
import matplotlib.pyplot as plt

omega = np.linspace(0, 3, 200)
ell_2_model = (2 * omega + 1) / (2 * (1 + omega))
ell_1 = 0.5

fig, ax = plt.subplots()
ax.plot(omega + 1, ell_2_model, 'b-', lw=2, label='Model prediction')
ax.axhline(ell_1, color='r', ls='--', lw=2, label='Actual $\\ell_2 \\approx \\ell_1$')
ax.axhspan(0.45, 0.55, color='red', alpha=0.1, label='Empirical range')
ax.set_xlabel(r'Wage growth factor $W_2 / W_1$')
ax.set_ylabel(r'Period 2 labor supply $\ell_2$')
ax.set_title('Model vs data: the labor supply puzzle')
ax.legend()
ax.grid(True, alpha=0.3)
plt.show()
```

## Occupational Variation

One response: assume $R\beta / \Omega = 1$ fixes aggregate labor supply, where $\Omega = W_2/W_1$. Then $(1-\ell_2)\Gamma_i = (1-\ell_1)$ for occupation-specific wage growth $\Omega_i = \Omega \Gamma_i$.

Plausible values of $\Gamma_i$ range from $0.5$ (manual laborers) to $1.5$ (doctors):

- $\Gamma = 0.5 \Rightarrow \ell_2 = 0$ (zero hours!)
- $\Gamma = 1.5 \Rightarrow \ell_2 = 2/3$ (much harder in middle age)

Empirically, cross-occupation variation in middle-age labor supply is small. The theory drastically overpredicts: a "small intertemporal elasticity of labor supply."

## Code: Occupational Labor Supply

```{pyodide}
import numpy as np
import matplotlib.pyplot as plt

ell_1 = 0.5
Gamma = np.linspace(0.3, 2.0, 200)
ell_2 = 1 - (1 - ell_1) / Gamma

fig, ax = plt.subplots()
ax.plot(Gamma, ell_2, 'b-', lw=2, label=r'Model: $\ell_2 = 1 - (1-\ell_1)/\Gamma_i$')
ax.axhspan(0.45, 0.55, color='red', alpha=0.15, label='Empirical range')
ax.axvline(0.5, color='green', ls=':', alpha=0.6)
ax.axvline(1.5, color='purple', ls=':', alpha=0.6)
ax.text(0.5, 0.05, 'Manual\nlaborers', ha='center', fontsize=8, color='green')
ax.text(1.5, 0.05, 'Doctors', ha='center', fontsize=8, color='purple')
ax.set_xlabel(r'Occupation wage growth factor $\Gamma_i$')
ax.set_ylabel(r'Period 2 labor supply $\ell_2$')
ax.set_title('Cross-occupation labor supply: model vs data')
ax.set_ylim(-0.1, 1.05)
ax.legend(fontsize=8)
ax.grid(True, alpha=0.3)
plt.show()
```

# The Overlapping Generations Model

## OLG Model: Demographics

The Diamond (1965) OLG model following Samuelson (1958):

- Two generations alive at any point: young (age 1) and old (age 2)
- Young population: $\mathcal{N}_t = \mathcal{N}_0 N^t$ where $N = 1+n$
- Households work only when young, earning $Y_{1,t}$; no income when old ($Y_{2,t+1} = 0$)
- They consume part of first-period income and save the rest

## OLG Model: Markets and Production

- Assets of the young fund next period's capital: $K_{t+1} = \mathcal{N}_t a_{1,t}$
- The old own the capital stock and consume everything (no bequest motive)
- Aggregate production: CRS technology $Y = F(K,L)$ with perfect competition
- No depreciation

## Production and Factor Prices

**Cobb-Douglas production function:**

$$F(K, L) = K^\varepsilon L^{1-\varepsilon} \quad \Rightarrow \quad f(k) = k^\varepsilon$$

**Factor prices equal marginal products** (where $R_{t+1} = 1 + r_t$):

$$W_t = (1-\varepsilon) k_t^\varepsilon$$

$$r_t = \varepsilon k_t^{\varepsilon - 1}$$

where $k_t = K_t / \mathcal{N}_t$ is capital per young worker.

## Individual Optimization

The young consumer maximizes $u(c_{1,t}) + \beta \, u(c_{2,t+1})$.

**Euler equation:** $u'(c_{1,t}) = \beta R_{t+1} u'(c_{2,t+1})$

With **log utility**: $c_{1,t} = W_{1,t}/(1+\beta)$ and $a_{1,t} = W_{1,t} \cdot \beta/(1+\beta)$

The saving rate $\beta/(1+\beta)$ is constant (a strong prediction of log utility).

## Capital Accumulation Dynamics

Since $k_{t+1} = a_{1,t}/N$ (assets per young worker, adjusted for population growth):

$$k_{t+1} = \underbrace{\frac{(1-\varepsilon)\beta}{N(1+\beta)}}_{\equiv \, \mathcal{Q}} \cdot k_t^\varepsilon$$

This is a nonlinear first-order difference equation in $k$.

Since $\varepsilon < 1$, the mapping is concave and converges monotonically to a unique steady state.

## Code: OLG Phase Diagram

```{pyodide}
import numpy as np
import matplotlib.pyplot as plt

epsilon = 0.33
beta = 0.96
N = 2.5  # Per-generation: ~3% annual growth compounded over 30 years
Q = (1 - epsilon) * beta / (N * (1 + beta))

k = np.linspace(0.01, 0.6, 200)
k_next = Q * k**epsilon

fig, ax = plt.subplots()
ax.plot(k, k_next, 'b-', lw=2, label=r'$k_{t+1} = \mathcal{Q} k_t^\varepsilon$')
ax.plot(k, k, 'k--', lw=1, label='45-degree line')

k_ss = Q**(1 / (1 - epsilon))
ax.plot(k_ss, k_ss, 'ro', ms=10, label=f'Steady state $\\bar{{k}} = {k_ss:.3f}$')

k0 = 0.05
kn = k0
for _ in range(8):
    kn1 = Q * kn**epsilon
    ax.plot([kn, kn], [kn, kn1], 'g-', alpha=0.5, lw=0.8)
    ax.plot([kn, kn1], [kn1, kn1], 'g-', alpha=0.5, lw=0.8)
    kn = kn1

ax.set_xlabel(r'$k_t$'); ax.set_ylabel(r'$k_{t+1}$')
ax.set_title('OLG model dynamics: convergence to steady state')
ax.legend()
ax.grid(True, alpha=0.3)
plt.show()
```

## Steady State

Setting $k_{t+1} = k_t = \bar{k}$:

$$\bar{k} = \mathcal{Q} \, \bar{k}^{\,\varepsilon} \quad \Longrightarrow \quad \bar{k} = \mathcal{Q}^{1/(1-\varepsilon)}$$

**Steady-state factor prices:**

$$\bar{W} = (1-\varepsilon)\bar{k}^{\,\varepsilon}, \qquad \bar{r} = \varepsilon \bar{k}^{\,\varepsilon - 1}$$

## Code: Comparative Statics

```{pyodide}
import numpy as np
import matplotlib.pyplot as plt

epsilon = 0.33

beta_vals = np.linspace(0.8, 1.0, 200)
N = 2.5
Q_vals = (1 - epsilon) * beta_vals / (N * (1 + beta_vals))
k_ss = Q_vals**(1 / (1 - epsilon))

fig, axes = plt.subplots(1, 2, figsize=(10, 4))

axes[0].plot(beta_vals, k_ss, 'b-', lw=2)
axes[0].set_xlabel(r'Discount factor $\beta$')
axes[0].set_ylabel(r'Steady-state capital $\bar{k}$')
axes[0].set_title('More patient $\\Rightarrow$ more capital')
axes[0].grid(True, alpha=0.3)

N_vals = np.linspace(1.5, 4.0, 200)  # Per-generation growth factors
beta_fix = 0.96
Q_N = (1 - epsilon) * beta_fix / (N_vals * (1 + beta_fix))
k_ss_N = Q_N**(1 / (1 - epsilon))

axes[1].plot(N_vals, k_ss_N, 'r-', lw=2)
axes[1].set_xlabel(r'Population growth $N$')
axes[1].set_ylabel(r'Steady-state capital $\bar{k}$')
axes[1].set_title('Faster growth $\\Rightarrow$ less capital per worker')
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

## Code: OLG Steady State (SymPy)

```{pyodide}
#| output: asis
from sympy import symbols, solve, simplify, Eq, diff
from sympy.printing.mathml import mathml

def show(expr):
    ml = mathml(expr, printer='presentation')
    print(f'<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">{ml}</math>')

k, eps, beta_s, N_pop = symbols('k epsilon beta N', positive=True)
n = symbols('n', positive=True)

Q = (1 - eps) * beta_s / (N_pop * (1 + beta_s))
Q_sym = symbols('Q')
print('<p><b>Capital accumulation coefficient:</b></p>')
show(Eq(Q_sym, Q))

k_bar = Q**(1 / (1 - eps))
k_ss = symbols('k_ss')
print('<p><b>Steady-state capital:</b></p>')
show(Eq(k_ss, k_bar))

W_bar = simplify((1 - eps) * k_bar**eps)
r_bar = simplify(eps * k_bar**(eps - 1))
W_ss, r_ss = symbols('W_ss r_ss')
print('<p><b>Factor prices:</b></p>')
show(Eq(W_ss, W_bar))
show(Eq(r_ss, r_bar))

f_k = k**eps
golden = solve(Eq(diff(f_k, k), n), k)
k_gold = symbols('k_gold')
print('<p><b>Golden rule capital:</b></p>')
show(Eq(k_gold, golden[0]))
```

## The Social Planner's Problem

A social planner maximizes welfare across generations:

$$V_t = \beta \, u(c_{2,t}) + \sum_{n=0}^{\infty} \beth^n v_{t+n}$$

where $\beth$ (beth) is the social discount factor.

**Resource constraint:** $K_t + F(K_t, \mathcal{N}_t) = K_{t+1} + \mathcal{N}_t c_{1,t} + \mathcal{N}_{t-1} c_{2,t}$

**Optimal steady state:** $1 + f'(\bar{k}^*) = N \beth^{-1}$

## Dynamic Efficiency and the Golden Rule

Per-capita steady-state consumption: $\bar{c} = f(\bar{k}) - n\bar{k}$

**Golden Rule** maximizes $\bar{c}$: $f'(\bar{k}^{**}) = n \;\Rightarrow\; \bar{k}^{**} = (n/\varepsilon)^{1/(\varepsilon - 1)}$

Three capital levels to compare:

- $\bar{k}$: competitive equilibrium
- $\bar{k}^*$: social optimum (depends on $\beth$)
- $\bar{k}^{**}$: golden rule (maximizes $\bar{c}$)

## Code: Golden Rule and Dynamic Efficiency

```{pyodide}
import numpy as np
import matplotlib.pyplot as plt

epsilon = 0.33
N = 2.5  # Per-generation
n = N - 1  # Net growth rate

k = np.linspace(0.001, 0.7, 300)
f_k = k**epsilon
c_ss = f_k - n * k

k_gold = (n / epsilon)**(1 / (epsilon - 1))
c_gold = k_gold**epsilon - n * k_gold

k_zero = n**(1 / (epsilon - 1))

beta = 0.96
Q = (1 - epsilon) * beta / (N * (1 + beta))
k_ce = Q**(1 / (1 - epsilon))
c_ce = k_ce**epsilon - n * k_ce

fig, ax = plt.subplots()
ax.plot(k, c_ss, 'b-', lw=2, label=r'$\bar{c} = f(\bar{k}) - n\bar{k}$')
ax.axhline(0, color='k', lw=0.5)
ax.plot(k_gold, c_gold, 'r*', ms=15, label=f'Golden rule $k^{{**}} = {k_gold:.2f}$')
ax.plot(k_ce, c_ce, 'go', ms=10, label=f'Competitive eq. $\\bar{{k}} = {k_ce:.2f}$')
ax.axvline(k_gold, color='r', ls=':', alpha=0.4)
ax.fill_betweenx([0, c_gold * 1.1], k_gold, k_zero,
                 color='red', alpha=0.1, label='Dynamically inefficient')
ax.set_xlabel(r'Steady-state capital $\bar{k}$')
ax.set_ylabel(r'Steady-state consumption $\bar{c}$')
ax.set_title('Golden Rule and dynamic efficiency')
ax.set_xlim(0, 0.7)
ax.legend(fontsize=8)
ax.grid(True, alpha=0.3)
plt.show()
```

## Code: Three Capital Levels

```{pyodide}
import numpy as np
import matplotlib.pyplot as plt

epsilon = 0.33
N = 2.5  # Per-generation
n = N - 1
beta = 0.96

Q = (1 - epsilon) * beta / (N * (1 + beta))
k_ce = Q**(1 / (1 - epsilon))

k_gold = (n / epsilon)**(1 / (epsilon - 1))

beth = 0.99
k_social = ((N / beth - 1) / epsilon)**(1 / (epsilon - 1))

labels = [r'$\bar{k}$ (competitive)', r'$\bar{k}^*$ (social, $\beth=0.99$)',
          r'$\bar{k}^{**}$ (golden rule)']
values = [k_ce, k_social, k_gold]
colors = ['#2196F3', '#FF9800', '#F44336']

fig, ax = plt.subplots()
bars = ax.bar(labels, values, color=colors, width=0.5)
for bar, v in zip(bars, values):
    ax.text(bar.get_x() + bar.get_width()/2, v + 0.005,
            f'{v:.3f}', ha='center', fontsize=10)
ax.set_ylabel('Capital per young worker')
ax.set_title('Comparing steady-state capital levels')
ax.grid(True, alpha=0.3, axis='y')
plt.tight_layout()
plt.show()
```

# The Envelope Condition

## The Multiperiod Problem

The consumer maximizes discounted lifetime utility:

$$\max \sum_{n=0}^{T-t} \beta^n \, u(c_{t+n})$$

subject to the **dynamic budget constraint:**

$$m_{t+1} = (m_t - c_t)R + y_{t+1}$$

where $m_t$ denotes market resources (cash-on-hand) at the beginning of period $t$.

## Bellman Equation

The problem in recursive form:

$$v_t(m_t) = \max_{c_t} \left\{ u(c_t) + \beta \, v_{t+1}\!\left((m_t - c_t)R + y_{t+1}\right) \right\}$$

**First order condition:**

$$u'(c_t) = R\beta \, v'_{t+1}(m_{t+1})$$

This relates marginal utility today to the marginal **value** of resources tomorrow, but how do we characterize $v'$?

## The Lower-Bound Function

Define a lower-bound function:

$$\underline{v}_t(m_t, c_t) = u(c_t) + \beta \, v_{t+1}((m_t - c_t)R + y_{t+1})$$

Its partial derivatives are:

$$\underline{v}_t^{\,c} = u'(c_t) - R\beta \, v'_{t+1}(m_{t+1})$$

$$\underline{v}_t^{\,m} = R\beta \, v'_{t+1}(m_{t+1})$$

Note that $\underline{v}_t^{\,c} = 0$ at the optimum (this is the FOC).

## Applying the Envelope Theorem

By the chain rule:

$$v'_t(m_t) = \underline{v}_t^{\,m} + c'_t(m_t) \cdot \underline{v}_t^{\,c}$$

Since the FOC implies $\underline{v}_t^{\,c} = 0$, the second term vanishes:

$$v'_t(m_t) = \underline{v}_t^{\,m} = R\beta \, v'_{t+1}(m_{t+1})$$

The marginal value of $m$ equals the return on saving, regardless of how the consumption function responds to $m$.

## Key Result: $v'(m) = u'(c)$

The FOC says $u'(c_t) = R\beta \, v'_{t+1}(m_{t+1})$.

The envelope result says $v'_t(m_t) = R\beta \, v'_{t+1}(m_{t+1})$.

Equating the right-hand sides:

$$\boxed{v'_t(m_t) = u'(c_t)}$$

**Marginal value of resources = marginal utility of consumption.**

This yields the **Euler equation** for general $T$-period problems:

$$u'(c_t) = R\beta \, u'(c_{t+1})$$

## The Mechanical Shortcut

The envelope theorem implies a practical rule: when differentiating the value function with respect to $m$, treat $c$ as constant (set $c'_t(m) = 0$).

Formally, from Bellman's equation:

$$v_t(m) = u(c^*(m)) + \beta \, v_{t+1}((m - c^*(m))R + y_{t+1})$$

Differentiating and treating $c^*$ as constant:

$$v'_t(m) = \beta R \, v'_{t+1}(m_{t+1})$$

This works because the FOC zeros out $\underline{v}^c$, so any term multiplied by it vanishes.

## Graphical Intuition

When $m$ increases by $dm$, the consumer can either:

1. **Consume it:** gain $u'(c) \, dm$ in utility
2. **Save it:** gain $R\beta \, v'(m_{t+1}) \, dm$ in continuation value

At the optimum, the FOC equates these two margins. The consumer is **indifferent at the margin** between consuming and saving the extra resources.

The total gain in value is the same regardless of which margin we evaluate. This is why the envelope works.

## Code: Value Function and Envelope

```{pyodide}
import numpy as np
import matplotlib.pyplot as plt

R, beta, rho = 1.04, 0.96, 2.0
y2 = 1.0

m1 = np.linspace(0.5, 8, 200)
total_wealth = m1 + y2 / R

# Analytical optimal c1 and c2
denom = 1 + R**(-1) * (R * beta) ** (1 / rho)
c1_opt = total_wealth / denom
c2_opt = (m1 - c1_opt) * R + y2

# Value function: v(m) = u(c1) + beta*u(c2)
v_vals = c1_opt**(1-rho)/(1-rho) + beta * c2_opt**(1-rho)/(1-rho)

# Numerical v'(m) vs analytical u'(c1)
dv_dm = np.gradient(v_vals, m1)
du_dc = c1_opt**(-rho)

fig, ax = plt.subplots()
ax.plot(m1, dv_dm, 'b-', lw=2, label=r"$v'(m)$ (numerical)")
ax.plot(m1, du_dc, 'r--', lw=2, label=r"$u'(c^*(m))$")
ax.set_xlabel('$m_1$')
ax.set_ylabel('Marginal value / marginal utility')
ax.set_title("Envelope result: $v'(m) = u'(c^*(m))$")
ax.legend()
ax.grid(True, alpha=0.3)
plt.show()
```

## Code: Saving Rate and the IES

```{pyodide}
import numpy as np
import matplotlib.pyplot as plt

beta = 0.96
rho_vals = [0.5, 1.0, 2.0, 4.0]
R_vals = np.linspace(0.8, 1.5, 200)

fig, ax = plt.subplots()
for rho in rho_vals:
    denom = 1 + R_vals**(-1) * (R_vals * beta) ** (1 / rho)
    mpc = 1 / denom
    saving_rate = 1 - mpc
    ax.plot(R_vals, saving_rate, lw=2,
            label=rf'$\rho={rho}$ (IES $= {1/rho:.1f}$)')

ax.set_xlabel('Gross interest rate $R$')
ax.set_ylabel('Saving rate $(m - c_1) / m$')
ax.set_title('Higher IES: saving responds more to $R$')
ax.legend()
ax.grid(True, alpha=0.3)
plt.show()
```

## Key Takeaways (1/2)

- **Euler equation:** $u'(c_1) = R\beta \, u'(c_2)$ governs all intertemporal consumption decisions
- **Fisherian Separation:** consumption growth depends on $R$ and $\beta$, not income timing
- **Labor supply puzzle:** the model drastically overpredicts the response of labor supply to predictable wage variation

## Key Takeaways (2/2)

- **OLG model:** competitive equilibria can be dynamically inefficient; the Golden Rule $f'(\bar{k}) = n$ maximizes steady-state consumption
- **Social optimum:** there is no particular relationship between the competitive equilibrium and the social planner's solution
- **Envelope theorem:** $v'(m) = u'(c)$; marginal value equals marginal utility, extending the Euler equation to general $T$-period problems

## Summary: How the Topics Connect

Each topic in this module builds on the Euler equation:

- **Fisher (2-period):** introduces the fundamental tradeoff $u'(c_1) = R\beta \, u'(c_2)$
- **Labor supply:** adds the leisure choice, revealing the model's limits when confronted with cross-occupation data
- **OLG:** embeds the individual Euler equation in general equilibrium, where capital accumulation can overshoot the efficient level
- **Envelope theorem:** generalizes the Euler equation from 2 periods to $T$ periods via $v'(m) = u'(c)$
